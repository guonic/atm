"""
Extract exit model training data from trading framework backtest results.

This module extracts position snapshots from backtest results generated by
the new trading framework, and converts them to the format required for
training the exit model.
"""

from typing import Dict, List, Optional
import pandas as pd
import logging

from qlib.data import D

logger = logging.getLogger(__name__)


def extract_snapshots_from_storage(
    storage,
    start_date: str,
    end_date: str,
) -> pd.DataFrame:
    """
    Extract position snapshots from storage backend.
    
    Args:
        storage: Storage backend instance (MemoryStorage or SQLStorage).
        start_date: Start date (YYYY-MM-DD).
        end_date: End date (YYYY-MM-DD).
    
    Returns:
        DataFrame with position snapshots.
    """
    snapshots = []
    
    # Get all snapshot keys from storage
    if hasattr(storage, 'get_all_keys'):
        snapshot_keys = storage.get_all_keys(prefix="snapshot:")
    else:
        # Fallback: try to get keys manually
        snapshot_keys = []
        # This is a simplified approach - in practice, you'd need to track keys
        logger.warning("Storage backend doesn't support get_all_keys, using fallback")
    
    # Load snapshots
    for key in snapshot_keys:
        snapshot_data = storage.load(key)
        if snapshot_data:
            snapshots.append(snapshot_data)
    
    if not snapshots:
        logger.warning("No snapshots found in storage")
        return pd.DataFrame()
    
    # Convert to DataFrame
    df = pd.DataFrame(snapshots)
    
    # Ensure date column is datetime
    if 'date' in df.columns:
        df['date'] = pd.to_datetime(df['date'])
    
    # Filter by date range
    if 'date' in df.columns:
        df = df[(df['date'] >= pd.Timestamp(start_date)) & (df['date'] <= pd.Timestamp(end_date))]
    
    logger.info(f"Extracted {len(df)} position snapshots")
    return df


def extract_from_backtest_results(
    results: Dict,
    start_date: str,
    end_date: str,
    add_future_labels: bool = True,
    future_days: int = 3,
    loss_threshold: float = -0.03,
) -> pd.DataFrame:
    """
    Extract exit model training data from backtest results.
    
    This function extracts position snapshots from the trading framework's
    backtest results and adds future labels for training.
    
    Args:
        results: Backtest results dictionary from run_custom_backtest().
            Should contain:
            - 'snapshots': List of account snapshots
            - 'positions': Dict of final positions
            - 'orders': List of all orders
        start_date: Start date (YYYY-MM-DD).
        end_date: End date (YYYY-MM-DD).
        add_future_labels: Whether to add future labels (default: True).
        future_days: Number of future days to look ahead for labels (default: 3).
        loss_threshold: Loss threshold for labeling (default: -0.03, i.e., -3%).
    
    Returns:
        DataFrame with position snapshots ready for exit model training.
        Columns:
            - trade_id: Trade identifier
            - date: Snapshot date
            - symbol: Stock symbol
            - close: Close price
            - high: High price
            - low: Low price
            - volume: Volume
            - entry_price: Entry price
            - highest_price_since_entry: Highest price since entry
            - days_held: Days held
            - current_return: Current return
            - drawdown: Drawdown from highest price
            - label: Exit label (1 if should exit, 0 otherwise)
    """
    # Extract position snapshots from storage
    storage = results.get('storage')
    if storage is None:
        logger.warning("No storage backend in results, cannot extract snapshots")
        return pd.DataFrame()
    
    # Get snapshots from storage
    snapshots_df = extract_snapshots_from_storage(storage, start_date, end_date)
    
    if snapshots_df.empty:
        logger.warning("No snapshots found in storage")
        return pd.DataFrame()
    
    # Reconstruct position history from orders
    # This is needed because storage snapshots might not have all the details
    orders = results.get('orders', [])
    positions = results.get('positions', {})
    
    # Build position timeline from orders
    position_timeline = _build_position_timeline(orders, start_date, end_date)
    
    # Merge with snapshots
    training_data = _merge_snapshots_with_timeline(
        snapshots_df,
        position_timeline,
        start_date,
        end_date,
    )
    
    # Add future labels if requested
    if add_future_labels:
        training_data = _add_future_labels(
            training_data,
            future_days=future_days,
            loss_threshold=loss_threshold,
        )
    
    return training_data


def _build_position_timeline(
    orders: List,
    start_date: str,
    end_date: str,
) -> pd.DataFrame:
    """
    Build position timeline from orders.
    
    Args:
        orders: List of Order objects.
        start_date: Start date (YYYY-MM-DD).
        end_date: End date (YYYY-MM-DD).
    
    Returns:
        DataFrame with position timeline.
    """
    timeline = []
    
    # Group orders by symbol and date
    for order in orders:
        if order.status.value not in ["FILLED", "PARTIAL_FILLED"]:
            continue
        
        if order.filled_price is None or order.filled_amount <= 0:
            continue
        
        timeline.append({
            'date': pd.Timestamp(order.date),
            'symbol': order.symbol,
            'side': order.side.value,
            'price': order.filled_price,
            'amount': order.filled_amount,
        })
    
    if not timeline:
        return pd.DataFrame()
    
    df = pd.DataFrame(timeline)
    df = df.sort_values(['symbol', 'date'])
    
    return df


def _merge_snapshots_with_timeline(
    snapshots_df: pd.DataFrame,
    timeline_df: pd.DataFrame,
    start_date: str,
    end_date: str,
) -> pd.DataFrame:
    """
    Merge snapshots with position timeline.
    
    Args:
        snapshots_df: DataFrame with position snapshots from storage.
        timeline_df: DataFrame with position timeline from orders.
        start_date: Start date (YYYY-MM-DD).
        end_date: End date (YYYY-MM-DD).
    
    Returns:
        Merged DataFrame with complete position information.
    """
    # For now, return snapshots_df as-is
    # In a full implementation, you would merge timeline data to fill in missing fields
    return snapshots_df


def _add_future_labels(
    training_data: pd.DataFrame,
    future_days: int = 3,
    loss_threshold: float = -0.03,
) -> pd.DataFrame:
    """
    Add future labels to training data.
    
    Label = 1 if future max loss exceeds threshold or return becomes negative.
    Label = 0 otherwise.
    
    Args:
        training_data: DataFrame with position snapshots.
        future_days: Number of future days to look ahead (default: 3).
        loss_threshold: Loss threshold for labeling (default: -0.03, i.e., -3%).
    
    Returns:
        DataFrame with 'label' column added.
    """
    if training_data.empty:
        return training_data
    
    # Group by symbol and trade_id (if available)
    training_data = training_data.copy()
    
    # Calculate future returns for each position
    labels = []
    
    for idx, row in training_data.iterrows():
        symbol = row['symbol']
        date = pd.Timestamp(row['date'])
        entry_price = row.get('entry_price', row.get('current_price', 0))
        
        if entry_price <= 0:
            labels.append(0)
            continue
        
        # Get future prices
        future_end_date = (date + pd.Timedelta(days=future_days)).strftime("%Y-%m-%d")
        
        try:
            future_data = D.features(
                instruments=[symbol],
                fields=["$close", "$high", "$low"],
                start_time=date.strftime("%Y-%m-%d"),
                end_time=future_end_date,
            )
            
            if future_data.empty or symbol not in future_data.columns.get_level_values(0):
                labels.append(0)
                continue
            
            # Get future prices
            symbol_data = future_data[symbol]
            future_closes = symbol_data['$close'].values
            future_highs = symbol_data['$high'].values
            
            # Calculate future returns
            future_returns = (future_closes - entry_price) / entry_price
            future_max_loss = (future_highs.min() - entry_price) / entry_price if len(future_highs) > 0 else 0
            
            # Label: 1 if max loss exceeds threshold or return becomes negative
            if future_max_loss < loss_threshold or (len(future_returns) > 0 and future_returns[-1] < 0):
                labels.append(1)
            else:
                labels.append(0)
        except Exception as e:
            logger.debug(f"Failed to calculate future label for {symbol} on {date}: {e}")
            labels.append(0)
    
    training_data['label'] = labels
    
    logger.info(f"Added labels: {sum(labels)} positive labels out of {len(labels)} total")
    
    return training_data


def save_training_data(
    training_data: pd.DataFrame,
    output_path: str,
) -> None:
    """
    Save training data to CSV file.
    
    Args:
        training_data: DataFrame with training data.
        output_path: Output file path.
    """
    training_data.to_csv(output_path, index=False)
    logger.info(f"Saved training data to {output_path}: {len(training_data)} rows")
