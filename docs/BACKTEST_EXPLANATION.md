# 回测框架中的多轮预测说明

## 为什么需要多轮预测？

## 为什么每次加载的数据范围不同？

这是 **Walk-Forward 回测**的正常行为，不是 bug！

### 数据加载逻辑

```
回测参数：start_date=2024-06-01, end_date=2025-12-01, pred_len=20, step_size=20

Step 1 (cutoff=2025-07-06):
  加载数据：2024-06-01 到 2025-07-06 ✅
  实际数据：265 行，范围 2024-06-03 ~ 2025-07-04

Step 2 (cutoff=2025-07-26):
  加载数据：2024-06-01 到 2025-07-26 ✅
  实际数据：280 行，范围 2024-06-03 ~ 2025-07-25
  (比 Step 1 多了 20 天的数据)
```

### 为什么时间窗口会变化？

**这是 Walk-Forward 回测的核心原则：**

1. **模拟真实场景**：在实际交易中，随着时间推移，你能看到的数据会越来越多
   - 在 2025-07-06 时，你只能看到 2025-07-06 之前的数据
   - 在 2025-07-26 时，你就能看到 2025-07-26 之前的数据（多了 20 天）

2. **避免未来信息泄露**：每个步骤只能使用"截止时间之前"的数据
   - Step 1 不能看到 2025-07-07 之后的数据
   - Step 2 不能看到 2025-07-27 之后的数据

3. **数据逐步累积**：每个步骤比前一步多看到一些历史数据
   - Step 1: 看到 265 天的数据
   - Step 2: 看到 280 天的数据（多了 15 个交易日）

### 为什么不能复用之前的数据？

虽然看起来可以复用，但实际上**必须重新加载**，因为：

1. **数据范围不同**：每个步骤的 `end_date` 不同
2. **数据库查询优化**：数据库可以高效地查询指定时间范围的数据
3. **内存管理**：不需要在内存中保存所有步骤的数据

### 性能优化建议

如果觉得每次重新加载数据太慢，可以考虑：

1. **缓存机制**（未来优化）：
   ```python
   # 可以添加数据缓存，避免重复查询相同的时间范围
   # 但需要确保每个步骤的数据范围正确
   ```

2. **减少步骤数**：增加 `step_size` 来减少步骤数
   ```python
   backtester.run(
       step_size=40,  # 从 20 改为 40，减少一半的步骤
   )
   ```

3. **数据库索引优化**：确保 `trade_date` 字段有索引，加快查询速度

## 为什么需要多轮预测？

在回测过程中，你会看到两种类型的"多轮预测"：

### 1. Walk-Forward 回测的多轮步骤（Step 9, Step 10...）

这是 **Walk-Forward 回测**的正常行为，用于模拟真实交易场景：

```
时间线示例：
2024-01-01 ────────── 2024-06-09 ────────── 2024-06-29 ────────── 2024-06-30
           历史数据      Step 9 预测点         Step 10 预测点        结束日期
```

**工作原理：**
- **Step 9**: 使用 2024-01-01 到 2024-06-09 的历史数据，预测未来20天（到 2024-06-29）
- **Step 10**: 使用 2024-01-01 到 2024-06-29 的历史数据，预测未来20天（到 2024-06-30）

**为什么需要这样做？**
1. **模拟真实场景**：在实际交易中，你只能使用当前时间点之前的历史数据
2. **评估模型稳定性**：测试模型在不同时间点的表现是否一致
3. **避免未来信息泄露**：确保预测只使用"过去"的数据，不会看到"未来"

**参数说明：**
- `pred_len=20`: 每次预测未来20天
- `step_size=20`: 每次向前移动20天（默认等于 pred_len）
- 如果 `step_size < pred_len`，预测会有重叠，可以更密集地评估模型

### 2. Kronos 模型生成过程中的迭代（20/20 进度条）

这是 **Kronos 自回归模型**的生成过程：

```
进度条显示：100%|████████████████| 20/20 [00:03<00:00, 5.27it/s]
```

**工作原理：**
Kronos 是一个**自回归（Autoregressive）模型**，需要逐天生成预测：

```python
# 伪代码说明
for i in range(pred_len):  # 20次迭代
    # 第1次迭代：使用历史数据 + 时间戳，生成第1天的预测
    day1_pred = model.predict(historical_data, timestamp_day1)
    
    # 第2次迭代：使用历史数据 + 第1天预测 + 时间戳，生成第2天的预测
    day2_pred = model.predict(historical_data, day1_pred, timestamp_day2)
    
    # 第3次迭代：使用历史数据 + 第1-2天预测 + 时间戳，生成第3天的预测
    day3_pred = model.predict(historical_data, [day1_pred, day2_pred], timestamp_day3)
    
    # ... 依此类推，直到生成20天的预测
```

**为什么需要20次迭代？**
1. **自回归特性**：每天的预测依赖于之前所有天的预测
2. **时间序列依赖**：股票价格具有时间依赖性，需要逐步生成
3. **上下文累积**：每次迭代都会将新生成的预测加入上下文，用于下一次预测

**代码位置：**
- `python/atm/ai/kronos/kronos.py` 中的 `auto_regressive_inference` 函数
- 第446行：`for i in ran(pred_len):` 循环

## 性能优化建议

### 1. 减少回测步骤数
如果回测时间范围很长，可以增加 `step_size` 来减少步骤数：

```python
# 默认：step_size = pred_len (20天)
backtester.run(
    ts_code="000001.SZ",
    start_date=datetime(2024, 1, 1),
    end_date=datetime(2024, 6, 30),
    pred_len=20,
    step_size=20,  # 每20天预测一次
)

# 优化：增加步长，减少步骤数
backtester.run(
    ts_code="000001.SZ",
    start_date=datetime(2024, 1, 1),
    end_date=datetime(2024, 6, 30),
    pred_len=20,
    step_size=40,  # 每40天预测一次，减少一半的步骤
)
```

### 2. 减少预测长度
如果只需要短期预测，可以减少 `pred_len`：

```python
backtester.run(
    ts_code="000001.SZ",
    start_date=datetime(2024, 1, 1),
    end_date=datetime(2024, 6, 30),
    pred_len=10,  # 只预测10天，减少生成时间
    step_size=10,
)
```

### 3. 使用 GPU 加速
Kronos 模型支持 GPU 加速，可以显著提升生成速度：

```python
predictor = KronosPredictor(
    db_config=db_config,
    device="cuda:0",  # 使用 GPU
)
```

## 总结

- **Walk-Forward 的多轮步骤**：模拟真实交易场景，评估模型在不同时间点的表现
- **Kronos 的20次迭代**：自回归模型逐天生成预测的必要过程
- **两者都是必要的**：前者确保回测的准确性，后者确保预测的质量

如果觉得回测太慢，可以通过调整 `step_size`、`pred_len` 或使用 GPU 来优化性能。

